## function to calculate the least-cost paths between locations 

lcp_function <- function (x,radius = 200,basemap,matrix_out = TRUE){
  
  require(rnaturalearth)
  require(rnaturalearthhires)
  require(sf)
  require(tidyr)
  require(dplyr)
  require(raster)
  require(ggplot2)
  require(gdistance)
  require(nngeo)
  require(fasterize)
  require(reshape2)
  
  
  # x is the sf dataframe with the coordinates for the sites of interest. This dataframe must have the column 'site.id' to specify the name of each site. 
  # radius is the radius around the sites that will be used to set up a dynamic 
  # basemap is a sf polygon that shows the coast. This will be generated by the code unless otherwise specified. 
  # matrix out is a logical determining whether a distance matrix will be returned (default - TRUE) or a data.frame (FALSE)
  
  #latitude and longitude projection 
  latlong <- "+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0"
  
  #Data check
  if(sum(names(x)%in%"site_id")!=1){stop("a column with the name 'site.id' must be included to capture the site name")}
  
  #load basemap for the least-cost path analysis
  if(is.null(basemap)){
    
    basemap <- rbind(ne_states(country = "Canada",returnclass = "sf")%>%
                       dplyr::select(name_en,geometry)%>%
                       st_as_sf()%>%
                       st_union()%>%
                       st_transform(latlong)%>%
                       st_as_sf()%>%
                       mutate(country="Canada"),
                     ne_states(country = "United States of America",returnclass = "sf")%>%
                       dplyr::select(name_en,geometry)%>%
                       st_as_sf()%>%
                       st_union()%>%
                       st_transform(latlong)%>%
                       st_as_sf()%>%
                       mutate(country="USA"))%>%st_union()%>%st_as_sf()
    
  }
  
  #make sure data is set to the projection used in the analysis
  x = x%>%st_transform(latlong)
  
  
  #create dynamic projection to set the boundaries of the least-cost path analysis
  pts_center <- x%>%
    summarise()%>%
    st_centroid()%>%
    st_transform(latlong)%>%
    suppressWarnings()%>%
    suppressMessages()
  
  aeqd <- sprintf("+proj=aeqd +lat_0=%s +lon_0=%s +x_0=0 +y_0=0",
                       st_coordinates(pts_center)[2], st_coordinates(pts_center)[1])
  
  #set cropping buffer to create a transition object
  
  max_dist <- (max(st_distance(x)%>%as.numeric()/1000)+25)%>%round() #maximum distance between stations + 25km radius
  
  buffer_pts <- st_buffer(pts_center%>%st_transform(aeqd),dist=units::set_units(max_dist,"km"))%>%st_bbox()%>%st_as_sfc()%>%st_sf()
  
  #create raster at 5 km scale that can be used to develop the transition object
  r=suppressWarnings(raster(raster::extent(buffer_pts),res=1*1000,crs=aeqd)%>%projectRaster(.,crs=latlong))
  
  coast <- suppressWarnings(basemap%>%
                            st_transform(aeqd)%>%
                            st_intersection(.,buffer_pts)%>%
                            st_transform(latlong))
  
  ind <- r%>%
    fasterize(coast,.)%>%
    values(.)%>%
    as.data.frame()%>%
    rename(val=1)%>%
    mutate(val=is.na(val))%>%
    pull(val)
  
  #set raster value for the transition matrix
  r[] <- 0 #land - no conductance
  r[ind] <- 1 #water (note set to 1, if you set to 10 you change the costDistance calculation)
  
  #raster used to ensure the sample sites are in water
  r2 <- r
  r2[] <- 10
  r2[ind] <- -10
  
  #adjust coordinates so they are in the water. 
  samplesite_adjusted <- x%>%
    mutate(site_id=factor(site_id,levels=c(x$site_id)))%>% #this will enforce the order of sample sites onto the grouping
    as.data.frame()%>%
    group_by(site_id)%>%
    do(coord_bump(.,r2))%>%
    ungroup()%>%
    mutate(site_id=as.character(site_id))%>%
    left_join(.,sample_sites)%>%
    st_as_sf(coords=c("lon_a","lat_a"),crs=latlong,remove=FALSE)
  
  #calculate the offset between the recorded location and the location that the site was bumped to. This can be added to the distance for that site to any other site
  samplesite_adjusted$offset=9999 #placeholder for the distances 
  
  for(i in samplesite_adjusted$site_id){
    
    site <- samplesite_adjusted%>%filter(site_id == i)
    
    samplesite_adjusted[samplesite_adjusted$site_id == i,"offset"] <- st_distance(site,st_as_sf(data.frame(site),coords=c("long","lat"),crs=st_crs(site)))%>%
      as.numeric()/1000#distance in km
    
    rm(site)
    
  }
  
  ## create row index that can be used for matching
  samplesite_adjusted$ind <- 1:nrow(samplesite_adjusted)
  
  ## create the transition object
  trans <- transition(r,transitionFunction = min,directions=16)%>%
    geoCorrection(.,type="c",multpl = FALSE)
  
  ## Least-cost path analysis
  lcp_df <- suppressWarnings(costDistance(trans,as_Spatial(samplesite_adjusted))/1000)
  
  
  #return a data.frame (site vs site) --- optional if matrix_out = TRUE
  if(!matrix_out){
  output <- melt(as.matrix(lcp_df), varnames = c("row", "col"))%>%
                     mutate(start = samplesite_adjusted%>%data.frame()%>%.[row,"site_id"],
                            end = samplesite_adjusted%>%data.frame()%>%.[col,'site_id'])%>%
                     rename(dist=value)%>%
                     dplyr::select(start,end,dist)
  
  #adjust for the bumps to water
  for(i in samplesite_adjusted$site_id){
    output[output$start == i & output$dist!=0 | output$end == i & output$dist!=0,"dist"] <- output[output$start == i & output$dist!=0 | 
                                                                 output$end == i & output$dist!=0,"dist"] + samplesite_adjusted%>%filter(site_id == i)%>%pull(offset)
    
    
  }
  
  
  }
  
  #return a distance matrix (sites by sites full matrix) -- DEFAULT
  if(matrix_out){
    
    output <- as.matrix(lcp_df)
    
    #match up the column names in the distance matrix
    rownames(output) <- samplesite_adjusted%>%data.frame()%>%pull(site_id) 
    colnames(output) <- samplesite_adjusted%>%data.frame()%>%pull(site_id) 
    
    #adjust for the bumps to water
    for(i in samplesite_adjusted$site_id){
       output[rownames(output)==i,output[rownames(output)==i,]>0] <- output[rownames(output)==i,output[rownames(output)==i,]>0] + samplesite_adjusted%>%filter(site_id == i)%>%pull(offset) #add offset to rows
       output[output[colnames(output)==i,]>0,colnames(output)==i] <- output[output[colnames(output)==i,]>0,colnames(output)==i] + samplesite_adjusted%>%filter(site_id == i)%>%pull(offset) #add offset to columns
     }
   
  }
  
  #end function and return output
  return(output)
  
}